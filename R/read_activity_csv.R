#' A Function to Read JAX Envision速 activity CSVs
#'
#' This function allows you to read activity CSVs generated by the JAX Envision速 software.
#' @param csv File path for the Envision速 CSV.
#' @param metadata a metadata object returned by `envision_metadata()`
#' @param tzone Time zone for the study. If left as \code{NULL}, the function will attempt to assume a time zone and throw a warning.
#' @param metrics Should the function expect cage (\code{"cage"}) or animal
#'  (\code{"animal"}) level activity metrics? Default: \code{NULL} tries to
#'  identify whether the csv is animal or cage level.
#' @returns A \code{tibble} with experimental data optimally formatted for downstream analysis.
#' @keywords Envision
#' @export
#' @examples
#' # Writing test cage-level CSV file for an example
#' activity_cage_csv <- tempfile("testactivity", fileext = ".csv")
#' readr::write_lines(activity_cage_csv_example, file = activity_cage_csv)
#'
#' # Reading in test cage-level activity CSV file
#' activity_cage <- read_activity_csv(csv = activity_cage_csv, tz = "US/Pacific")
#'
#' # Glimpsing test activity CSV file
#' dplyr::glimpse(activity_cage_csv)
#'
#' # Removing the activity file
#' file.remove(activity_cage_csv)
#'
#' #' Writing test animal-level CSV file for an example
#' activity_animal_csv <- tempfile("testactivity", fileext = ".csv")
#' readr::write_lines(activity_animal_csv_example, file = activity_animal_csv)
#'
#' # Reading in test animal-level activity CSV file
#' activity_animal <- read_activity_csv(csv = activity_animal_csv, tz = "US/Pacific")
#'
#' # Glimpsing test activity CSV file
#' dplyr::glimpse(activity_animal)
#'
#' # Removing the activity file
#' file.remove(activity_animal_csv)
read_activity_csv <- function(csv, metadata = NULL,
                              tzone = NULL, metrics = NULL) {
  # Ensuring required packages are loaded
  stopifnot(requireNamespace("readr", quietly = TRUE))
  stopifnot(requireNamespace("janitor", quietly = TRUE))
  stopifnot(requireNamespace("dplyr", quietly = TRUE))
  stopifnot(requireNamespace("tibble", quietly = TRUE))

  if (!is.null(metadata)) {
    # Running some checks on the metadata
    stopifnot(is.list(metadata))
    stopifnot(is.character(metadata[["tzone"]]))
    stopifnot(metadata[["tzone"]] %in% timezones_df$tz_name)

    if (is.null(tzone)) {
      tzone <- ifelse(is.na(metadata[["tzone"]]),
        NULL, metadata[["tzone"]]
      )
    } else {
      warning(
        "time zone info provided in both metadata and arguments, ",
        "assuming the argument passed to tzone is the time zone"
      )
    }
  }

  activity_tibble <- read_activity_csv_raw(csv, tzone, metrics)
  return(activity_tibble)
}

#' Low-level internal read_activity_csv
#' @param csv File path for the Envision速 CSV.
#' @param tzone Time zone for the study. If left as \code{NULL}, the function will attempt to assume a time zone and throw a warning.
#' @param metrics Should the function expect cage (\code{"cage"}) or animal
#' @noRd
read_activity_csv_raw <- function(csv, tzone = NULL,
                                  metrics = NULL) {
  # Ensuring required packages are loaded
  stopifnot(requireNamespace("readr", quietly = TRUE))
  stopifnot(requireNamespace("janitor", quietly = TRUE))
  stopifnot(requireNamespace("dplyr", quietly = TRUE))
  stopifnot(requireNamespace("tibble", quietly = TRUE))

  # Doing variable bindings
  start_date_local <- start_time_local <- startlocal_utc <-
    start <- utc_offset_h <- min_starttime <- assume <- min_starttime_utc <-
    tz_name <- is_dst <- tz_isdst <- NULL

  # Looking for a version of the activity CSV
  first10_csv <- base::readLines(csv, n = 10)

  # Looking at starting comment characters within the first 10 lines of the CSV
  # NOTE: this is to ensure that the comment character can be read in the body
  # of the sheet.
  comment_char_csv <- grep("^#", first10_csv, value = TRUE)
  activity_csv_version <- grep("[Vv]ersion",
    comment_char_csv,
    value = TRUE
  )
  header_col_csv <- grep("^start,", first10_csv, value = TRUE)

  if (length(activity_csv_version) == 0) {
    activity_csv_version <- "v0.0.0.9000"
  } else {
    activity_csv_version <- paste0(
      "v",
      gsub(
        "^.*[Vv]ersion[:]?\\s?(.*)\\s?.?$",
        "\\1", activity_csv_version
      )
    )
    if (!activity_csv_version %in% envisionR::csv_column_defs$version_numbers) {
      stop("invalid Envision csv version number: ", activity_csv_version)
    }
  }

  if (is.null(metrics)) {
    metrics <- tolower(gsub(
      "^.*movement\\.(.*)\\.cm_s.*$",
      "\\1",
      header_col_csv
    ))
    if (grepl("animal", metrics)) {
      metrics <- "animal"
    } else if (grepl("cage", metrics)) {
      metrics <- "cage"
    }
  }

  # Getting definitions of columns by version
  metrics <- tolower(metrics)
  if (metrics %in% c("cage", "animal")) {
    metrics <- paste0(metrics, "_activity")
    activity_cols_def <- envisionR::csv_column_defs[[metrics]][[activity_csv_version]]
  } else {
    stop("metrics should be defined as either cage or animal level")
  }

  # Reading in raw data
  activity_data <- readr::read_csv(csv,
    skip = length(comment_char_csv),
    col_types = activity_cols_def,
    show_col_types = FALSE
  ) |>
    janitor::clean_names() |>
    tibble::as_tibble()

  # Starting by listing compatible time zones
  compatible_tzones <- activity_data |>
    dplyr::mutate(utc_offset_h = get_utc_offset(
      as.POSIXct(paste(
        start_date_local,
        start_time_local
      )),
      start,
      as_numeric = TRUE
    )) |>
    dplyr::group_by(utc_offset_h) |>
    dplyr::mutate(min_starttime = min(start)) |>
    dplyr::select(utc_offset_h, min_starttime) |>
    dplyr::summarize(min_starttime_utc = min(min_starttime)) |>
    dplyr::left_join(timezones_df, by = "utc_offset_h")

  # Assigning time zone
  if (is.null(tzone)) {
    # Attempting to automagically impute an assumed time zone if tz is NULL
    # Identifying all unique UTC offsets in the dataset
    # Then finding compatible assumed time zones
    probable_tzones <- compatible_tzones |>
      dplyr::filter(assume == 1) |>
      dplyr::ungroup() |>
      dplyr::mutate(tz_isdst = FALSE) |>
      as.data.frame()

    for (i in seq_len(nrow(probable_tzones))) {
      probable_tzones[i, "tz_isdst"] <- as.POSIXlt(
        probable_tzones[i, "min_starttime_utc"],
        probable_tzones[i, "tz_name"]
      )$isdst == 1
    }

    probable_tzones <- probable_tzones |>
      dplyr::filter(is_dst == tz_isdst)

    # Getting unique time zones that are assumed.
    unique_tzs <- probable_tzones |>
      dplyr::pull(tz_name) |>
      unique()

    # Setting time zone according to a series of conditions
    if (length(unique_tzs) == 1) {
      tz_assume <- unique_tzs
    } else {
      stop("could not assume a time zone unambiguously.")
    }
    # Throwing a warning if time zone is set as null
    warning(paste0(
      "Assuming time zone: ", tz_assume,
      ". Set time zone explicitly if different."
    ))
  } else {
    if (tzone %in% timezones_df$tz_name) {
      tz_assume <- tzone
      if (!(tzone %in% (compatible_tzones |> dplyr::pull(tz_name)))) {
        warning(paste(
          "UTC offset for the", tzone,
          "time zone mismatches suggested time zones."
        ))
      }
    } else {
      stop(paste("time zone", tzone, "is not a system time zone."))
    }
  }
  activity_data <- activity_data |>
    dplyr::mutate(
      start = as.POSIXct(start, tz = tz_assume),
      tzone = tz_assume
    )

  return(activity_data)
}
