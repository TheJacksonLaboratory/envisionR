#' A Function to Read JAX Envision® activity CSVs
#'
#' This function allows you to read activity CSVs generated by the JAX Envision® software.
#' @param csv File path for the Envision® CSV.
#' @param tz Time zone for the study. If left as \code{NULL}, the function will attempt to assume a time zone and throw a warning.
#' @param metrics Should the function expect cage (\code{"cage"}) or animal
#'  (\code{"animal"}) level activity metrics? Default: \code{NULL} tries to
#'  identify whether the csv is animal or cage level.
#' @returns A \code{tibble} with experimental data optimally formatted for downstream analysis.
#' @keywords Envision
#' @export
#' @examples
#' # Writing test CSV file for an example
#' activity_csv <- tempfile("testactivity", fileext = ".csv")
#' readr::write_lines(activity_csv_example, file = activity_csv)
#'
#' # Reading in test activity CSV file
#' activity <- read_activity_csv(csv = activity_csv, tz = "US/Pacific")
#'
#' # Glimpsing test activity CSV file
#' dplyr::glimpse(activity)
#'
#' # Removing the activity file
#' file.remove(activity_csv)

read_activity_csv <- function(csv, tz = NULL,
                              metrics = NULL) {

  # Ensuring required packages are loaded
  stopifnot(requireNamespace("readr", quietly = TRUE))
  stopifnot(requireNamespace("janitor", quietly = TRUE))
  stopifnot(requireNamespace("dplyr", quietly = TRUE))
  stopifnot(requireNamespace("tibble", quietly = TRUE))

  # Doing variable bindings
  start_date_local <- start_time_local <- startlocal_utc <-
    start <- utc_offset_h <- min_starttime <- assume <- min_starttime_utc <-
    tz_name <- is_dst <- tz_isdst <- NULL

  # Looking for a version of the activity CSV
  first10_csv = base::readLines(csv, n = 10)
  activity_csv_version <- grep("[Vv]ersion",
                               first10_csv,
                               value = TRUE)
  header_col_csv = grep("^start,", first10_csv, value = TRUE)

  if (length(activity_csv_version) == 0) {
    activity_csv_version <- "v0.0.0.9000"
  } else {
    activity_csv_version <- paste0("v",
                                  gsub("^.*[Vv]ersion[:]?\\s?(.*)\\s?.?$",
                                       "\\1", activity_csv_version))
  }

  if (is.null(metrics)) {
    metrics = gsub("^.*movement\\.(.*)\\.cm_s.*$", "\\1", header_col_csv)
    metrics = ifelse(grepl("animal", metrics), "animal", "cage")
  }

  # Getting definitions of columns by version
  metrics = tolower(metrics)
  if (metrics %in% c("cage", "animal")) {
    activity_cols_def <- envisionR::csv_column_defs[[metrics]][[activity_csv_version]]
  } else {
    stop("metrics should be defined as either cage or animal level")
  }

  # Reading in raw data
  activity_data <- readr::read_csv(csv,
                                   col_types = activity_cols_def,
                                   show_col_types = FALSE) |>
    janitor::clean_names() |>
    tibble::as_tibble()

  # Starting by listing compatible time zones
  compatible_tzones <- activity_data |>
    dplyr::mutate(utc_offset_h = get_utc_offset(as.POSIXct(paste(start_date_local,
                                                                 start_time_local)),
                                                start, as_numeric = TRUE)) |>
    dplyr::group_by(utc_offset_h) |>
    dplyr::mutate(min_starttime = min(start)) |>
    dplyr::select(utc_offset_h, min_starttime) |>
    dplyr::summarize(min_starttime_utc = min(min_starttime)) |>
    dplyr::left_join(timezones_df, by = "utc_offset_h")

  # Assigning time zone
  if (is.null(tz)) {
    # Attempting to automagically impute an assumed time zone if tz is NULL
    # Identifying all unique UTC offsets in the dataset
    # Then finding compatible assumed time zones
    probable_tzones <- compatible_tzones |>
      dplyr::filter(assume == 1) |>
      dplyr::ungroup() |>
      dplyr::mutate(tz_isdst = FALSE) |>
      as.data.frame()

    for (i in seq_len(nrow(probable_tzones))) {
      probable_tzones[i,"tz_isdst"] <- as.POSIXlt(probable_tzones[i,"min_starttime_utc"],
                                                  probable_tzones[i,"tz_name"])$isdst == 1
    }

    probable_tzones <- probable_tzones |>
      dplyr::filter(is_dst == tz_isdst)

    # Getting unique time zones that are assumed.
    unique_tzs <- probable_tzones |>
      dplyr::pull(tz_name) |>
      unique()

    # Setting time zone according to a series of conditions
    if (length(unique_tzs) == 1) {
      tz_assume <- unique_tzs
    } else {
      stop("could not assume a time zone unambiguously.")
    }
    activity_data <- activity_data |>
      dplyr::mutate(start = as.POSIXct(start, tz = tz_assume),
                    tzone = tz_assume)
    # Throwing a warning if
    warning(paste0("Assuming time zone: ", tz_assume,
                   ". Set time zone explicitly if different."))
  } else {
    if (tz %in% timezones_df$tz_name) {
      activity_data <- activity_data |>
        dplyr::mutate(start = as.POSIXct(start, tz = tz),
                      tzone = tz)
      if (!(tz %in% (compatible_tzones |> dplyr::pull(tz_name)))) {
        warning(paste("UTC offset for the", tz,
                      "time zone mismatches suggested time zones."))
      }
    } else {
      stop(paste("time zone", tz, "is not a system time zone."))
    }
  }

  return(activity_data)
}

#' Dummy JAX Envision® activity CSV lines formatted the same as exported activity data.
#'
#' A dataset containing four lines of fabricated JAX Envision® activity data.
#'  These lines follow the format of a JAX Envision® activity CSV.
#'  When read properly, the lines for cage-level data have raw column titles as follows:
#'
#'  \itemize{
#'    \item \code{start}. the date and time at the start of the aggregation bin (coerced from UTC to local time).
#'    \item \code{start_date_local}. the start date (in the time zone in which the data were collected).
#'    \item \code{start_time_local}. the start time (in the time zone in which the data were collected).
#'    \item \code{study_code}. a unique code for each study.
#'    \item \code{aggregation_seconds}. the number of seconds aggregated to generate this dataset (3600 is 1 hour).
#'    \item \code{group_name}. a user-defined group name, often used to label experimental groups of interest.
#'    \item \code{cage_name}. the name of the cage that the data represent.
#'    \item \code{animals_cage_quantity}. the number of animals in the cage, sometimes called cage density or occupancy.
#'    \item \code{light_cycle}. whether the data were collected in the light or dark cycle.
#'    \item \code{movement_mean_per_cage_cm_s_hour}. cage-level movement in cm/s for a specified period of time (1 hour in this example)
#'    \item \code{wheel_occupancy_mean_per_cage_animals_hour}. amount of time spent on the wheel at the cage level.
#'    \item \code{food_occupancy_mean_per_cage_animals_hour}. amount of time spent in proximity to the food hopper at the cage level.
#'    \item \code{water_occupancy_mean_per_cage_animals_hour}. amount of time spent in proximity to the water bottles at the cage level.
#'    \item \code{tzone}. time zone of the dataset.
#'  }
#'
#' @docType data
#' @keywords datasets
#' @name activity_csv_example
#' @usage data(activity_csv_example)
#' @format a character vector with 5 lines, the first line is a header.
NULL

#' Column definition
#'
#' Definitions for the columns of different Envision® csv types and versions.
#'
#' @docType data
#' @keywords datasets
#' @name csv_column_defs
#' @usage data(csv_column_defs)
#' @format a list with both cage-level and animal-level column specifications
NULL
