#' A Function to Read JAX Envision® annotation CSVs
#'
#' This function allows you to read annotation CSVs generated by the JAX Envision® software.
#' @param csv File path for the Envision® annotation CSV.
#' @param tz Time zone for the study. If left as \code{NULL}, the function will attempt to assume a time zone and throw a warning.
#' @returns A \code{tibble} with annotation data optimally formatted for downstream analysis.
#'
#' When read properly, the lines for annotation data have column titles as follows:
#'
#'  \itemize{
#'    \item \code{id}. the ID of the annotation, usually a number.
#'    \item \code{created}. the date and time the annotation was created (coerced from UTC to local time).
#'    \item \code{created_date_local}. the date the annotation was created (in the time zone in which the data were collected).
#'    \item \code{created_time_local}. the time the annotation was created (in the time zone in which the data were collected).
#'    \item \code{pin_start_date_local}. the date of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_start_time_local}. the time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_date_local}. the date of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time_local}. the time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{study_code}. a unique code for each study.
#'    \item \code{group_name}. a user-defined group name, often used to label experimental groups of interest.
#'    \item \code{cage_name}. the name of the cage that the data represent.
#'    \item \code{creator}. the name of the user or bot who created the annotation.
#'    \item \code{contents}. the annotation.
#'    \item \code{reply_to}. if the annotation is a reply, the name of the user or bot to whom the reply is directed.
#'    \item \code{hashtags}. any hashtags in the annotation.
#'    \item \code{pin_start_time}. the date and time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time}. athe date and time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{tzone}. time zone of the dataset.
#'  }
#'
#' @keywords Envision
#' @export
#' @examples
#' # Writing test CSV file
#' annotation_csv <- tempfile("testannotation", fileext = ".csv")
#' readr::write_lines(annotation_csv_example, file = annotation_csv)
#'
#' # Reading in test CSV file
#' annotation <- read_annotation_csv(csv = annotation_csv, tz = "US/Pacific")
#'
#' # Glimpsing annotation CSV
#' dplyr::glimpse(annotation)
#'
#' # Removing the annotation temp file
#' file.remove(annotation_csv)
read_annotation_csv <- function(csv, tz = NULL) {
  # Ensuring required packages are loaded
  stopifnot(requireNamespace("readr", quietly = TRUE))
  stopifnot(requireNamespace("janitor", quietly = TRUE))
  stopifnot(requireNamespace("dplyr", quietly = TRUE))
  stopifnot(requireNamespace("tibble", quietly = TRUE))

  # Doing variable bindings
  created <- created_date_local <- created_time_local <-
    createdlocal_utc <- utc_offset_h <- min_createdtime <- assume <-
    min_createdtime_utc <- pin_start_date_local <- pin_start_time_local <-
    pin_start_time <- pin_end_date_local <- pin_end_time_local <-
    pin_end_time <- tz_isdst <- is_dst <- annotation_csv_version <-
    tz_name <- NULL

  # Looking for a version of the annotation CSV
  first10_csv <- base::readLines(csv, n = 10)

  # Looking at starting comment characters within the first 10 lines of the CSV
  # NOTE: this is to ensure that the comment character can be read in the body
  # of the sheet.
  comment_char_csv <- grep("^#", first10_csv, value = TRUE)
  annotation_csv_version <- grep("[Vv]ersion",
    comment_char_csv,
    value = TRUE
  )
  header_col_csv <- grep("^start,", first10_csv, value = TRUE)

  if (length(annotation_csv_version) == 0) {
    annotation_csv_version <- "v0.0.0.9000"
  } else {
    annotation_csv_version <- paste0(
      "v",
      gsub(
        "^.*[Vv]ersion[:]?\\s?(.*)\\s?.?$",
        "\\1", annotation_csv_version
      )
    )
    if (!annotation_csv_version %in% envisionR::csv_column_defs$version_numbers) {
      stop("invalid Envision csv version number: ", annotation_csv_version)
    }
  }

  annotation_cols_def <- envisionR::csv_column_defs[["annotation"]][[annotation_csv_version]]

  # Reading in raw data
  annotation_data <- readr::read_csv(csv,
    skip = length(comment_char_csv),
    col_types = annotation_cols_def,
    show_col_types = FALSE
  ) |>
    janitor::clean_names() |>
    tibble::as_tibble()

  # Starting by listing compatible time zones
  compatible_tzones <- annotation_data |>
    dplyr::mutate(utc_offset_h = get_utc_offset(
      as.POSIXct(paste(
        created_date_local,
        created_time_local
      )),
      created,
      as_numeric = TRUE
    )) |>
    dplyr::group_by(utc_offset_h) |>
    dplyr::mutate(min_createdtime = min(created)) |>
    dplyr::select(utc_offset_h, min_createdtime) |>
    dplyr::summarize(min_createdtime_utc = min(min_createdtime)) |>
    dplyr::left_join(timezones_df, by = "utc_offset_h")

  # Assigning time zone
  if (is.null(tz)) {
    # Attempting to automagically impute an assumed time zone if tz is NULL
    # Identifying all unique UTC offsets in the dataset
    # Then finding compatible assumed time zones
    probable_tzones <- compatible_tzones |>
      dplyr::filter(assume == 1) |>
      dplyr::ungroup() |>
      dplyr::mutate(tz_isdst = FALSE) |>
      as.data.frame()

    for (i in seq_len(nrow(probable_tzones))) {
      probable_tzones[i, "tz_isdst"] <- as.POSIXlt(
        probable_tzones[i, "min_createdtime_utc"],
        probable_tzones[i, "tz_name"]
      )$isdst == 1
    }

    probable_tzones <- probable_tzones |>
      dplyr::filter(is_dst == tz_isdst)

    # Getting unique time zones that are assumed.
    unique_tzs <- probable_tzones |>
      dplyr::pull(tz_name) |>
      unique()

    # Setting time zone according to a series of conditions
    if (length(unique_tzs) == 1) {
      tz_assume <- unique_tzs
    } else {
      stop("could not assume a time zone unambiguously.")
    }
    # Throwing a warning if stated time zone is not present in assumed time zones
    warning(paste0(
      "Assuming time zone: ", tz_assume,
      ". Set time zone explicitly if different."
    ))
  } else {
    if (tz %in% timezones_df$tz_name) {
      tz_assume <- tz
      if (!(tz %in% (compatible_tzones |> dplyr::pull(tz_name)))) {
        warning(paste(
          "UTC offset for the", tz,
          "time zone mismatches suggested time zones."
        ))
      }
    } else {
      stop(paste("time zone", tz, "is not a system time zone."))
    }
  }
  annotation_data <- annotation_data |>
    dplyr::mutate(
      created = as.POSIXct(created, tz = tz_assume),
      pin_start_time = paste0(
        as.character(pin_start_date_local), " ",
        as.character(pin_start_time_local)
      ),
      pin_start_time = ifelse(is.na(pin_start_date_local),
        NA, pin_start_time
      ),
      pin_start_time = as.POSIXct(pin_start_time,
        tz = tz_assume, optional = TRUE
      ),
      pin_end_time = paste0(
        as.character(pin_end_date_local), " ",
        as.character(pin_end_time_local)
      ),
      pin_end_time = ifelse(is.na(pin_end_date_local),
        NA, pin_end_time
      ),
      pin_end_time = as.POSIXct(pin_end_time,
        tz = tz_assume, optional = TRUE
      ),
      tzone = tz
    )

  return(annotation_data)
}
