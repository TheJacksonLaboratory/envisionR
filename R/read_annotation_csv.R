#' A Function to Read JAX Envision® annotation CSVs
#'
#' This function allows you to read annotation CSVs generated by the JAX Envision® software.
#' @param csv File path for the Envision® annotation CSV.
#' @param tz Time zone for the study. If left as \code{NULL}, the function will attempt to assume a time zone and throw a warning.
#' @returns A \code{tibble} with annotation data optimally formatted for downstream analysis.
#'
#' When read properly, the lines for annotation data have column titles as follows:
#'
#'  \itemize{
#'    \item \code{id}. the ID of the annotation, usually a number.
#'    \item \code{created}. the date and time the annotation was created (coerced from UTC to local time).
#'    \item \code{created_date_local}. the date the annotation was created (in the time zone in which the data were collected).
#'    \item \code{created_time_local}. the time the annotation was created (in the time zone in which the data were collected).
#'    \item \code{pin_start_date_local}. the date of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_start_time_local}. the time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_date_local}. the date of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time_local}. the time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{study_code}. a unique code for each study.
#'    \item \code{group_name}. a user-defined group name, often used to label experimental groups of interest.
#'    \item \code{cage_name}. the name of the cage that the data represent.
#'    \item \code{creator}. the name of the user or bot who created the annotation.
#'    \item \code{contents}. the annotation.
#'    \item \code{reply_to}. if the annotation is a reply, the name of the user or bot to whom the reply is directed.
#'    \item \code{hashtags}. any hashtags in the annotation.
#'    \item \code{pin_start_time}. the date and time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time}. athe date and time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{tzone}. time zone of the dataset.
#'  }
#'
#' @keywords Envision
#' @export
#' @examples
#' # Writing test CSV file
#' annotation_csv <- tempfile("testannotation", fileext = ".csv")
#' readr::write_lines(annotation_csv_example, file = annotation_csv)
#'
#' # Reading in test CSV file
#' annotation <- read_annotation_csv(csv = annotation_csv, tz = "US/Pacific")
#'
#' # Glimpsing annotation CSV
#' dplyr::glimpse(annotation)
#'
#' # Removing the annotation temp file
#' file.remove(annotation_csv)

read_annotation_csv <- function(csv, tz = NULL) {

  # Ensuring required packages are loaded
  stopifnot(requireNamespace("readr", quietly = TRUE))
  stopifnot(requireNamespace("janitor", quietly = TRUE))
  stopifnot(requireNamespace("dplyr", quietly = TRUE))
  stopifnot(requireNamespace("lubridate", quietly = TRUE))
  stopifnot(requireNamespace("tibble", quietly = TRUE))

  # Doing variable bindings
  created <- created_date_local <- created_time_local <-
    createdlocal_utc <- utc_offset_h <- min_createdtime <- assume <-
    min_createdtime_utc <- pin_end_date_local <- pin_end_time_local <-
    pin_start_time_local <- tz_isdst <- is_dst <-
    pin_start_date_local <- tz_name <- NULL

  # Reading in raw data
  annotation_data <- readr::read_csv(csv,
                                     col_types = list(ID = readr::col_double(),
                                                      created = readr::col_datetime(format = ""),
                                                      created_date.local = readr::col_date(format = ""),
                                                      created_time.local = readr::col_time(format = ""),
                                                      pin_start_date.local = readr::col_date(format = ""),
                                                      pin_start_time.local = readr::col_time(format = ""),
                                                      pin_end_date.local = readr::col_date(format = ""),
                                                      pin_end_time.local = readr::col_time(format = ""),
                                                      study_code = readr::col_character(),
                                                      group_name = readr::col_character(),
                                                      cage_name = readr::col_character(),
                                                      creator = readr::col_character(),
                                                      contents = readr::col_character(),
                                                      reply_to = readr::col_character(),
                                                      hashtags = readr::col_character()),
                                     show_col_types = FALSE) |>
    janitor::clean_names() |>
    tibble::as_tibble()

  # Starting by listing compatible time zones
  compatible_tzones <- annotation_data |>
    dplyr::mutate(createdlocal_utc = paste(created_date_local, created_time_local),
                  createdlocal_utc = lubridate::ymd_hms(createdlocal_utc,
                                                        tz = "UTC", quiet = TRUE),
                  utc_offset_h = round(as.numeric(createdlocal_utc - created), 0)) |>
    dplyr::group_by(utc_offset_h) |>
    dplyr::mutate(min_createdtime = min(created)) |>
    dplyr::select(utc_offset_h, min_createdtime) |>
    dplyr::summarize(min_createdtime_utc = min(min_createdtime)) |>
    dplyr::left_join(timezones_df, by = "utc_offset_h")

  # Assigning time zone
  if (is.null(tz)) {
    # Attempting to automagically impute an assumed time zone if tz is NULL
    # Identifying all unique UTC offsets in the dataset
    # Then finding compatible assumed time zones
    probable_tzones = compatible_tzones |>
      dplyr::filter(assume == 1) |>
      dplyr::ungroup() |>
      dplyr::mutate(tz_isdst = lubridate::dst(lubridate::with_tz(min_createdtime_utc, tzone = tz_name))) |>
      dplyr::filter(is_dst == tz_isdst)

    # Getting unique time zones that are assumed.
    unique_tzs <- probable_tzones |>
      dplyr::pull(tz_name) |>
      unique()

    # Setting time zone according to a series of conditions
    if (length(unique_tzs) == 1) {
      tz_assume <- unique_tzs
    } else {
      stop("could not assume a time zone unambiguously.")
    }
    annotation_data <- annotation_data |>
      dplyr::mutate(created = lubridate::with_tz(created, tzone = tz_assume),
                    pin_start_time = lubridate::ymd_hms(paste(as.character(pin_start_date_local),
                                                   as.character(pin_start_time_local)),
                                             tz = tz_assume, quiet = TRUE),
                    pin_end_time = lubridate::ymd_hms(paste(as.character(pin_end_date_local),
                                                 as.character(pin_end_time_local)),
                                             tz = tz_assume, quiet = TRUE),
                    tzone = tz_assume)
    # Throwing a warning if stated time zone is not present in assumed time zones
    warning(paste0("Assuming time zone: ", tz_assume,
                   ". Set time zone explicitly if different."))
  } else {
    if (tz %in% timezones_df$tz_name) {
      annotation_data <- annotation_data |>
        dplyr::mutate(created = lubridate::with_tz(created, tzone = tz),
                      pin_start_time = lubridate::ymd_hms(paste(as.character(pin_start_date_local),
                                                                as.character(pin_start_time_local)),
                                                          tz = tz, quiet = TRUE),
                      pin_end_time = lubridate::ymd_hms(paste(as.character(pin_end_date_local),
                                                              as.character(pin_end_time_local)),
                                                        tz = tz, quiet = TRUE),
                      tzone = tz)
      if (!(tz %in% (compatible_tzones |> dplyr::pull(tz_name)))) {
        warning(paste("UTC offset for the", tz,
                      "time zone mismatches suggested time zones."))
      }
    } else {
      stop(paste("time zone", tz, "is not a system time zone."))
    }
  }

  return(annotation_data)
}

#' Dummy JAX Envision® annotation CSV lines formatted the same as exported annotation data.
#'
#' A dataset containing four lines of fabricated JAX Envision® annotation data.
#'  These lines follow the format of a JAX Envision® annotation CSV.
#'  When read properly, the lines for annotation data have column titles as follows:
#'
#'  \itemize{
#'    \item \code{id}. the ID of the annotation, usually a number.
#'    \item \code{created}. the date and time the annotation was created (coerced from UTC to local time).
#'    \item \code{created_date_local}. the date the annotation was created (in the time zone in which the data were collected).
#'    \item \code{created_time_local}. the time the annotation was created (in the time zone in which the data were collected).
#'    \item \code{pin_start_date_local}. the date of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_start_time_local}. the time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_date_local}. the date of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time_local}. the time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{study_code}. a unique code for each study.
#'    \item \code{group_name}. a user-defined group name, often used to label experimental groups of interest.
#'    \item \code{cage_name}. the name of the cage that the data represent.
#'    \item \code{creator}. the name of the user or bot who created the annotation.
#'    \item \code{contents}. the annotation.
#'    \item \code{reply_to}. if the annotation is a reply, the name of the user or bot to whom the reply is directed.
#'    \item \code{hashtags}. any hashtags in the annotation.
#'    \item \code{pin_start_time}. the date and time of the start of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{pin_end_time}. athe date and time of the end of the period to which the annotation refers (in the time zone in which the data were collected).
#'    \item \code{tzone}. time zone of the dataset.
#'  }
#'
#' @docType data
#' @keywords datasets
#' @name annotation_csv_example
#' @usage data(annotation_csv_example)
#' @format a character vector with 5 lines, the first line is a header.
NULL
